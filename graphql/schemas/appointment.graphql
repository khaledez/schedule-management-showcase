extend type QueryRoot {
  ### Appointment Queries
  """
  Get appointment
  """
  appointment(id: ID!): Appointment
  """
  Find appointments by ids Max 100 ids
  """
  appointmentsByIds(ids: [ID!]!): [Appointment!]
  """
  List appointments
  """
  appointments(
    after: String
    before: String
    first: Int
    last: Int
    reverse: Boolean
    """
    Supported filter parameters:
        - patientId
        - doctorId
        - startDate
        - endDate
        - status (AppointmentStatusCode)
     - appointmentTypeId (AppointmentTypeCode)
    See https://shopify.dev/concepts/about-apis/search-syntax#search-query-syntax
    """
    query: String
    sortKey: AppointmentSortKeys!
  ): AppointmentConnection!
  ### Availability Queries
  """
  Get availability
  """
  availabilityById(id: ID!): Availability
  """
  Find availability by ids
  """
  availabilityByIds(ids: [ID!]!): [Availability!]
  """
  List availability
  """
  availability(
    after: String
    before: String
    first: Int
    last: Int
    reverse: Boolean
    """
    Supported filter parameters:
        - doctorId
        - startDate
        - endDate
        - appointmentTypeId (AppointmentTypeCode)
    See https://shopify.dev/concepts/about-apis/search-syntax#search-query-syntax
    """
    query: String
    sortKey: AvailabilitySortKeys!
  ): AvailabilityConnection!
}

extend type Mutation {
  appointmentCreate(input: AppointmentCreateInput!): AppointmentCreatePayload
  appointmentExtend(
    """
    appointment id
    """
    id: ID!
    input: AppointmentExtendInput!
  ): AppointmentCreatePayload
  appointmentCancel(
    """
    appointment id
    """
    id: ID!
    input: AppointmentCancelInput!
  ): AppointmentCreatePayload
  appointmentAssignDoctor(
    """
    appointment id
    """
    id: ID!
    """
    doctor id to assign at the appointment
    """
    doctorId: ID!
  ): AppointmentCreatePayload
  appointmentChangeAssignedDoctor(
    """
    appointment id
    """
    id: ID!
    input: AppointmentChangeAssignedDoctorInput!
  ): AppointmentCreatePayload
  appointmentSchedule(input: AppointmentScheduleInput): AppointmentCreatePayload
  appointmentReschedule(
    """
    appointment id to reschedule
    """
    id: ID!
    input: AppointmentRescheduleInput
  ): AppointmentCreatePayload

  availabilityCreate(
    input: AvailabilityCreateInput!
  ): AvailabilityCreatePayload!
  """
  Create many availability at the same time.
  """
  availabilityBulkCreate(
    input: [AvailabilityCreateInput!]!
  ): AvailabilityBulkCreatePayload
  """
  Create or update or delete bulk availabiliy.
  """
  availabilityBulkPatch(
    input: [AvailabilityBulkPatchInput!]!
  ): AvailabilityBulkCreatePayload
  availabilityRemove(
    """
    availability id
    """
    id: ID!
  ): AvailabilityCreatePayload!
}

input AppointmentCreateInput {
  patientId: ID!
  date: AWSDate!
  typeId: ID!
  startTime: AWSTime
  statusId: ID
  priorityId: ID
  # complains: String
  # clinic_notes: String
}

input AppointmentExtendInput {
  provisionalDate: AWSDate!
  """
  extension reason message
  """
  message: String!
}

input AppointmentCancelInput {
  provisionalDate: AWSDate!
  """
  cancellation reason message
  """
  message: String
  removeAvailabilitySlot: Boolean
}

input AppointmentChangeAssignedDoctorInput {
  doctorId: ID!
  """
  change Assignement doctors reason message
  """
  message: String
}

input AppointmentScheduleInput {
  appointmentId: ID!
  availabilityId: ID!
  doctorId: ID!
  patientId: ID!
}

input AppointmentRescheduleInput {
  """
  reason for rescheduling the appointment
  """
  reason: String
  """
  remove availability slot for the doctor
  """
  removeAvailability: Boolean
  """
  new availability id
  """
  newAvailabilityId: Boolean!
}

input AvailabilityCreateInput {
  date: AWSDate!
  startTime: AWSTime!
  durationMin: Int!
  doctorId: ID!
  appointmentTypeId: ID!
}

input AvailabilityDeleteInput {
  id: ID!
}

input AvailabilityBulkPatchInput {
  availabilityToCreate: [AvailabilityCreateInput!]
  availabilityToDelete: [AvailabilityDeleteInput!]
}

type AppointmentCreatePayload {
  appointment: Appointment!
  errors: [UserError!]!
}

type AvailabilityBulkCreatePayload {
  """
  The IDs of the effected availability.
  """
  ids: [ID!]
  """
  List of the effected availability
  """
  availability: [Availability!]!
  errors: [UserError!]!
}

type AvailabilityCreatePayload {
  availability: Availability!
  errors: [UserError!]!
}

enum AppointmentSortKeys {
  DATE
  TIME
}

enum AvailabilitySortKeys {
  DATE
  DOCTOR_ID
}

type Availability implements Node & CreatedProps {
  id: ID!
  date: AWSDate!
  startTime: AWSTime!
  endTime: AWSTime
  durationMin: Int!
  appointment: Appointment
  doctor: Doctor!
  type: AppointmentType!
  createdAt: AWSDateTime!
  createdBy: User!
}

type Appointment implements Node & Entity {
  id: ID!
  clinic: Clinic!
  patient: Patient
  doctor: Doctor
  availability: Availability
  previousAppointment: Appointment
  date: AWSDate!
  status: AppointmentStatus
  type: AppointmentType
  priority: AppointmentPriority
  startTime: AWSTime
  # Add cancel object / keep it see what's the perfect.
  cancelReason: String
  cancelAction: AppointmentActions
  # Means: is_active_appointment
  upcomingAppointment: Boolean
  provisionalAppointment: Boolean # calculated
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime
  canceledAt: AWSDateTime
  createdBy: User!
  updatedBy: User
  canceledBy: User
  # It would return the action for dropdown list
  nextPossibleActions: [AppointmentActions]!
  # This will return the next status has to be (Button).
  nextPossibleStatus: AppointmentStatus!
}

type AppointmentType implements Node & Lookup {
  id: ID!
  nameEn: String!
  nameFr: String!
  code: String!
}

type AppointmentStatus implements Node & Lookup {
  id: ID!
  nameEn: String!
  nameFr: String!
  group: AppointmentStatusGroup!
  """
  This depends on the clinic and each clinic has own state machine.
  Example:
    PENDING
    CONFIRMED1
    CONFIRMED2
    ARRIVED
    READY
  """
  code: String!
  clinicId: ID!
}

type AppointmentStatusGroup implements Node & Lookup {
  id: ID!
  nameEn: String!
  nameFr: String!
  code: AppointmentStatusGroupCode!
}

type AppointmentActions implements Node & Lookup {
  id: ID!
  nameEn: String!
  nameFr: String!
  """

  """
  code: AppointmentActionsType!
}

type AppointmentPriority implements Node & Lookup {
  id: ID!
  nameEn: String!
  nameFr: String!
  """
  This depends on the clinic and each clinic has own state machine.
  Example:
    A
    B
  """
  code: String!
}

# type CancelReasonType implements Node & Lookup {
#   id: ID!
#   nameEn: String!
#   nameFr: String!
#   code:
# }

type AppointmentConnection {
  edges: [AppointmentEdge!]!
  pageInfo: PageInfo!
}

type AppointmentEdge {
  cursor: String!
  node: Appointment!
}

type AvailabilityConnection {
  edges: [AvailabilityEdge!]!
  pageInfo: PageInfo!
}

type AvailabilityEdge {
  cursor: String!
  node: Availability!
}

enum AppointmentActionsType {
  CANCELED
  CHANGE_DOCTOR
  EXTEND
  RESCHEDULE
  SCHEDULE
  UPDATE
}

enum AppointmentStatusGroupCode {
  ARRIVED
  AVAILABILE
  BOOKED
  RELEASED
}
