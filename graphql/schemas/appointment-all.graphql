schema {
  query: QueryRoot
  mutation: Mutation
}

directive @generated on FIELD_DEFINITION

type Appointment implements Node & Entity {
  id: ID!
  clinic: Clinic!
  patient: Patient
  doctor: Doctor
  availability: Availability
  previousAppointment: Appointment
  date: AWSDate!
  status: AppointmentStatus
  type: AppointmentType
  startTime: AWSTime
  provisionalDate: AWSDate

  """Add cancel object / keep it see what's the perfect."""
  cancelRescheduleText: String
  cancelRescheduleId: AppointmentAction

  """Means: is_active_appointment"""
  upcomingAppointment: Boolean
  provisionalAppointment: Boolean
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime
  canceledAt: AWSDateTime
  createdBy: User!
  updatedBy: User
  canceledBy: User

  """It would return the action for dropdown list included the next action"""
  secondryActions: [AppointmentAction!]!

  """This will return the next status has to be (Button)."""
  primaryAction: AppointmentStatus!
}

type AppointmentAction implements Node & Lookup {
  id: ID!
  nameEn: String!
  nameFr: String!
  code: AppointmentActionType!
}

enum AppointmentActionType {
  CANCEL
  CHANGE_APPT_TYPE
  CHANGE_DATE
  CHANGE_DOCTOR
  RESCHEDULE_APPT
}

input AppointmentCancelInput {
  """Provisional date"""
  date: AWSDate
  priorityId: ID

  """cancellation reason message"""
  reason: String
  removeAvailability: Boolean
}

input AppointmentChangeDateInput {
  date: AWSDate!

  """extension reason message"""
  reason: String!
}

type AppointmentConnection {
  edges: [AppointmentEdge!]!
  pageInfo: PageInfo!
}

input AppointmentCreateInput {
  patientId: ID!
  date: AWSDate!
  typeId: ID!
}

type AppointmentCreatePayload {
  appointment: Appointment
  errors: [UserError!]
}

type AppointmentEdge {
  cursor: String!
  node: Appointment!
}

input AppointmentRescheduleInput {
  """reason for rescheduling the appointment"""
  reason: String

  """remove availability slot for the doctor"""
  removeAvailability: Boolean
}

input AppointmentSearchSortInput {
  key: AppointmentSortKey!
  order: SortOrder
}

enum AppointmentSortKey {
  DATE
  TIME
}

type AppointmentStatus implements Node & Lookup {
  id: ID!
  nameEn: String!
  nameFr: String!
  group: AppointmentStatusGroup!

  """
  This depends on the clinic and each clinic has own state machine.
  Example:
    PENDING
    CONFIRMED1
    CONFIRMED2
    ARRIVED
    READY
  """
  code: String!
}

type AppointmentStatusGroup implements Node & Lookup {
  id: ID!
  nameEn: String!
  nameFr: String!
  code: AppointmentStatusGroupCode!
}

enum AppointmentStatusGroupCode {
  BOOK
  CHECKIN
  COMPLETED
  CONFIRM
  READY
}

type AppointmentType implements Node & Lookup {
  id: ID!
  nameEn: String!
  nameFr: String!
  code: String!
}

type Availability implements Node & Entity {
  id: ID!
  date: AWSDate!
  startTime: AWSTime!
  endTime: AWSTime
  durationMin: Int!
  appointment: Appointment
  doctor: Doctor!
  type: AppointmentType!
  createdAt: AWSDateTime!
  createdBy: User!
  updatedAt: AWSDateTime
  updatedBy: User
}

type AvailabilityBulkCreatePayload {
  """The IDs of the effected availability."""
  ids: [ID!]

  """List of the effected availability"""
  availability: [Availability!]!
  errors: [UserError!]!
}

input AvailabilityBulkPatchInput {
  create: [AvailabilityCreateInput!]
  delete: [AvailabilityDeleteInput!]
}

type AvailabilityConnection {
  edges: [AvailabilityEdge!]!
  pageInfo: PageInfo!
}

input AvailabilityCreateInput {
  date: AWSDate!
  startTime: AWSTime!
  durationMin: Int!
  doctorId: ID!
  appointmentTypeId: ID!
}

type AvailabilityCreatePayload {
  availability: Availability!
  errors: [UserError!]!
}

input AvailabilityDeleteInput {
  id: ID!
}

type AvailabilityEdge {
  cursor: String!
  node: Availability!
}

input AvailabilitySearchSortInput {
  key: AvailabilitySortKey!
  order: SortOrder
}

enum AvailabilitySortKey {
  DATE
  DOCTOR_ID
}

scalar AWSDate

scalar AWSDateTime

scalar AWSTime

type Clinic implements Node {
  id: ID!
}

type Doctor implements Node {
  id: ID!
}

interface Entity {
  createdAt: AWSDateTime!
  createdBy: User!
  updatedAt: AWSDateTime
  updatedBy: User
}

interface Lookup {
  nameEn: String!
  nameFr: String!
}

type Mutation {
  appointmentCreate(input: AppointmentCreateInput!): AppointmentCreatePayload
  appointmentChangeDateById(
    """appointment id"""
    id: ID!
    input: AppointmentChangeDateInput!
  ): AppointmentCreatePayload
  appointmentChangeDateByPatientId(
    """patient id"""
    id: ID!
    input: AppointmentChangeDateInput!
  ): AppointmentCreatePayload
  appointmentCancel(
    """appointment id"""
    id: ID!
    input: AppointmentCancelInput!
  ): AppointmentCreatePayload
  appointmentScheduleById(
    """appointment id"""
    id: ID!

    """availability id"""
    availabilityId: ID!
  ): AppointmentCreatePayload
  appointmentScheduleByPatientId(
    """patient id"""
    id: ID!

    """availability id"""
    availabilityId: ID!
  ): AppointmentCreatePayload
  appointmentReschedule(
    """appointment id to reschedule"""
    id: ID!

    """new availability id"""
    availabilityId: ID!
    input: AppointmentRescheduleInput
  ): AppointmentCreatePayload

  """Create or update or delete bulk availabiliy."""
  availabilityBulkPatch(input: AvailabilityBulkPatchInput!): AvailabilityBulkCreatePayload!
  availabilityRemove(
    """availability id"""
    id: ID!
  ): AvailabilityCreatePayload!
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  total: Int
  startCursor: String!
  endCursor: String!
}

type Patient implements Node {
  id: ID!
}

type QueryRoot {
  """Get appointment"""
  appointment(id: ID!): Appointment

  """Find appointments by ids Max 100 ids"""
  appointmentsByIds(ids: [ID!]!): [Appointment!]

  """List appointments"""
  appointments(
    after: String
    before: String
    first: Int
    last: Int

    """
    Supported filter parameters:
        - patientId
        - doctorId
        - startDate
        - endDate
        - status (AppointmentStatusCode)
        - appointmentTypeId (AppointmentTypeCode)
    See https://shopify.dev/concepts/about-apis/search-syntax#search-query-syntax
    """
    query: String
    sort: [AppointmentSearchSortInput]!
  ): AppointmentConnection!

  """Get availability"""
  availabilityById(id: ID!): Availability

  """Find availability by ids"""
  availabilityByIds(ids: [ID!]!): [Availability!]

  """List availability"""
  availability(
    after: String
    before: String
    first: Int
    last: Int

    """
    Supported filter parameters:
        - doctorId
        - startDate
        - endDate
        - appointmentTypeId (AppointmentTypeCode)
    See https://shopify.dev/concepts/about-apis/search-syntax#search-query-syntax
    """
    query: String
    sort: [AvailabilitySearchSortInput!]
  ): AvailabilityConnection!
}

enum SortOrder {
  ASC
  DESC
}

type User implements Node {
  id: ID!
}

"""Represents an error in the input of a mutation."""
type UserError {
  """Path to the input field which caused the error."""
  field: [String!]

  """The error message."""
  message: String!
}
